<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>Hello World | Hexo</title><meta name="author" content="John Doe"><meta name="copyright" content="John Doe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Redisredis线程模型redis6.0之前 单线程（网络IO&#x2F;执行命令） 因为redis在内存中，瓶颈不是cpu所以不需要多线程，多线程会增加复杂度，带来并发和死锁的问题，线程切换带来资源消耗 redis6.0之后 网络IO使用多线程 随着网络硬件的提升，redis的性能瓶颈是网络IO redis持久化AOF日志 redis执行完一条命令，会将该命令追加写入一个文件（先执行命令到内">
<meta property="og:type" content="article">
<meta property="og:title" content="Hello World">
<meta property="og:url" content="http://example.com/2023/03/27/Redis/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Redisredis线程模型redis6.0之前 单线程（网络IO&#x2F;执行命令） 因为redis在内存中，瓶颈不是cpu所以不需要多线程，多线程会增加复杂度，带来并发和死锁的问题，线程切换带来资源消耗 redis6.0之后 网络IO使用多线程 随着网络硬件的提升，redis的性能瓶颈是网络IO redis持久化AOF日志 redis执行完一条命令，会将该命令追加写入一个文件（先执行命令到内">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-03-27T05:08:51.016Z">
<meta property="article:modified_time" content="2023-03-27T05:09:49.328Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/03/27/Redis/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Hello World',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-27 13:09:49'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Hexo"><span class="site-name">Hexo</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Hello World</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-03-27T05:08:51.016Z" title="Created 2023-03-27 13:08:51">2023-03-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-03-27T05:09:49.328Z" title="Updated 2023-03-27 13:09:49">2023-03-27</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Hello World"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h3 id="redis线程模型"><a href="#redis线程模型" class="headerlink" title="redis线程模型"></a>redis线程模型</h3><p>redis6.0之前</p>
<p>单线程（网络IO&#x2F;执行命令）</p>
<p>因为redis在内存中，瓶颈不是cpu所以不需要多线程，多线程会增加复杂度，带来并发和死锁的问题，线程切换带来资源消耗</p>
<p>redis6.0之后</p>
<p>网络IO使用多线程</p>
<p>随着网络硬件的提升，redis的性能瓶颈是网络IO</p>
<h3 id="redis持久化"><a href="#redis持久化" class="headerlink" title="redis持久化"></a>redis持久化</h3><p><strong>AOF日志</strong></p>
<p>redis执行完一条命令，会将该命令追加写入一个文件（先执行命令到内存，在记录日志到磁盘）</p>
<p>3种硬盘协会策略</p>
<ul>
<li>always：每次写操作执行完，同步将AOF日志写回硬盘</li>
<li>everysec：每秒写回</li>
<li>no，不主动写回，由操作系统决定</li>
</ul>
<p>AOF重写</p>
<p>避免AOF文件越写越大，按照键值对去数据库重新读取最新数据放入新的AOF文件</p>
<p>由后台子进程bgrewriteaof执行，在重写时，主进程可以继续执行，将放入AOF重写缓冲区，当子进程重写完后，发送一个信号给主进程，主进程将新的命令追加写入AOF文件</p>
<p><strong>RDB快照</strong></p>
<p>全量复制</p>
<p>执行bgsave创建一个子进程来生成RDB文件，不会阻塞主进程</p>
<p>利用写时复制来解决 进行rdb快照时，主进程也能继续执行指令</p>
<p><strong>混合模式</strong></p>
<p>先用rdb快照，再用AOF重写缓冲区写入新执行的命令</p>
<p>可读性较差  </p>
<h3 id="redis过期删除"><a href="#redis过期删除" class="headerlink" title="redis过期删除"></a>redis过期删除</h3><p>redis采用惰性删除和定期删除</p>
<p>惰性删除</p>
<p>执行一条命令，会先查过期字典，查询key是否过期，如果过期会删除</p>
<p>会出现无效占用</p>
<p>定时删除</p>
<p>时间不好设置</p>
<p>主从模式中，从服务器不能主动删除过期键，只能通过主服务器执行del</p>
<h3 id="redis内存淘汰"><a href="#redis内存淘汰" class="headerlink" title="redis内存淘汰"></a>redis内存淘汰</h3><p><strong>LRU最近最少使用</strong></p>
<p>用一个链表管理缓存数据，带来额外开销</p>
<p>若有数据被访问，会移动到链表头部，数据量太多性能会很低</p>
<p>redis在对象结构中添加一个字段来记录最后一次访问时间</p>
<p>优点：节省空间提升缓存性能</p>
<p>缺点：缓存污染，读取大量数据时，但只读一次会让这些数据存留很久</p>
<p><strong>LFU最近最不常使用</strong></p>
<h3 id="redis缓存设计"><a href="#redis缓存设计" class="headerlink" title="redis缓存设计"></a>redis缓存设计</h3><p>缓存雪崩</p>
<p>大量数据同时过期失效</p>
<p>解决</p>
<ul>
<li>设置不同时间</li>
<li>设置不过期</li>
</ul>
<p>缓存击穿</p>
<p>热点key过期</p>
<p>解决</p>
<ul>
<li>互斥锁方案</li>
<li>不设置过期时间，后台异步更新缓存</li>
</ul>
<p>缓存穿透</p>
<p>缓存和数据库不存在的数据</p>
<p>解决</p>
<ul>
<li>非法请求限制，对参数校验</li>
<li>设置null或者默认值返回</li>
<li>布隆过滤器，不访问数据库</li>
</ul>
<p>动态缓存热点数据</p>
<p>用一个队列存热点数据，访问就靠前，定期过滤掉队列靠后数据，再从数据库随机读取数据进来</p>
<h3 id="redis缓存更新策略"><a href="#redis缓存更新策略" class="headerlink" title="redis缓存更新策略"></a>redis缓存更新策略</h3><p>cache aside 旁路缓存</p>
<p>read&#x2F;write through 读穿&#x2F;写穿</p>
<p>write back 写回</p>
<p>先更新数据库，再删除缓存</p>
<p>如何保证两个操作的原子性？</p>
<p>重试机制 和超时</p>
<p>将删除操作放入消息队列，由消费者来消费，消费失败再重新消费，成功后 删除消息队列数据</p>
<p>mysql binlog</p>
<p>阿里canal</p>
<p>数据库更新成功后，存入binlog再删除缓存</p>
<h3 id="redis实战"><a href="#redis实战" class="headerlink" title="redis实战"></a>redis实战</h3><h4 id="redis实现延迟队列"><a href="#redis实现延迟队列" class="headerlink" title="redis实现延迟队列"></a>redis实现延迟队列</h4><p>淘宝订单超时</p>
<p>打车未接单取消</p>
<p>外卖未接单取消</p>
<h4 id="redis大key"><a href="#redis大key" class="headerlink" title="redis大key"></a>redis大key</h4><p>key对应的value很大</p>
<p>影响</p>
<ul>
<li>客户端超时阻塞</li>
<li>网路阻塞：流量消耗大</li>
<li>阻塞其他线程</li>
<li>内存分布不均匀</li>
</ul>
<p>如何找到大key？</p>
<p><strong>redis-cli –bigkeys</strong></p>
<p>在从节点使用</p>
<p>在低峰期使用</p>
<p>缺点</p>
<p>只找最大的</p>
<p>集合只找内存大小，不看元素个数</p>
<p><strong>SCAN命令</strong></p>
<p><strong>RdbTools</strong></p>
<p>如何删除？</p>
<p>批量删除</p>
<p>异步删除 不用del 用unlink子进程删除</p>
<h4 id="redis不支持回滚"><a href="#redis不支持回滚" class="headerlink" title="redis不支持回滚"></a>redis不支持回滚</h4><p>实际生产环境不会发生</p>
<p>实现复杂</p>
<h4 id="redis实现分布式锁"><a href="#redis实现分布式锁" class="headerlink" title="redis实现分布式锁"></a>redis实现分布式锁</h4><p>红锁解决redis集群下 分布式锁失效的问题</p>
<p>设置多个单独的主节点，当半数节点加锁成功，才会成功</p>
<p>删除由于是多个操作所以为了保证原子性，使用lua脚本</p>
<h2 id="5个基本数据类型"><a href="#5个基本数据类型" class="headerlink" title="5个基本数据类型"></a>5个基本数据类型</h2><h3 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h3><p>虽然 Redis 是用 C 语言写的，但是 Redis 并没有使用 C 的字符串表示，而是自己构建了一种 <strong>简单动态字符串</strong>（Simple Dynamic String，<strong>SDS</strong>）。相比于 C 的原生字符串，Redis 的 SDS 不光可以保存文本数据还可以保存二进制数据，并且获取字符串长度复杂度为 O(1)（C 字符串为 O(N)）,除此之外，Redis 的 SDS API 是安全的，不会造成缓冲区溢出。</p>
<hr>
<p>应用场景</p>
<ul>
<li><strong>需要存储常规数据的场景</strong></li>
</ul>
<p>缓存 session、token、图片地址、序列化后的对象(相比较于 Hash 存储更节省内存)。</p>
<ul>
<li><strong>需要计数的场景</strong></li>
</ul>
<p>用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数。</p>
<ul>
<li><strong>分布式锁</strong></li>
</ul>
<p>利用 <code>SETNX key value</code> 命令可以实现一个最简易的分布式锁（存在一些缺陷，通常不建议这样实现分布式锁）</p>
<h3 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h3><p>Redis 的 List 的实现为一个 <strong>双向链表</strong>，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。</p>
<hr>
<p>应用场景</p>
<ul>
<li><strong>信息流展示</strong></li>
</ul>
<p>最新文章、最新动态。</p>
<ul>
<li><strong>消息队列</strong></li>
</ul>
<p>Redis List 数据结构可以用来做消息队列，只是功能过于简单且存在很多缺陷，不建议这样做。</p>
<h3 id="Hash（哈希）"><a href="#Hash（哈希）" class="headerlink" title="Hash（哈希）"></a>Hash（哈希）</h3><p>Redis 中的 Hash 是一个 String 类型的 field-value（键值对） 的映射表，特别适合用于存储对象，后续操作的时候，你可以直接修改这个对象中的某些字段的值。</p>
<p>Hash 类似于 JDK1.8 前的 <code>HashMap</code>，内部实现也差不多(数组 + 链表)。不过，Redis 的 Hash 做了更多优化。</p>
<hr>
<p>应用场景</p>
<ul>
<li><strong>对象数据存储场景</strong></li>
</ul>
<p>用户信息、商品信息、文章信息、购物车信息。</p>
<h3 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h3><p>Redis 中的 Set 类型是一种无序集合，集合中的元素没有先后顺序但都唯一，有点类似于 Java 中的 <code>HashSet</code> 。当你需要存储一个列表数据，又不希望出现重复数据时，Set 是一个很好的选择，并且 Set 提供了判断某个元素是否在一个 Set 集合内的重要接口，这个也是 List 所不能提供的。</p>
<p>你可以基于 Set 轻易实现交集、并集、差集的操作，比如你可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。这样的话，Set 可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程。</p>
<hr>
<p>应用场景</p>
<ul>
<li><strong>需要存放的数据不能重复的场景</strong></li>
</ul>
<p>站 UV 统计（数据量巨大的场景还是 <code>HyperLogLog</code>更适合一些）、文章点赞、动态点赞等场景。</p>
<ul>
<li><strong>需要获取多个数据源交集、并集和差集的场景</strong></li>
</ul>
<p>共同好友(交集)、共同粉丝(交集)、共同关注(交集)、好友推荐（差集）、音乐推荐（差集） 、订阅号推荐（差集+交集） 等场景。</p>
<ul>
<li><strong>需要随机获取数据源中的元素的场景</strong></li>
</ul>
<p>抽奖系统、随机。<code>SPOP</code>（随机获取集合中的元素并移除，适合不允许重复中奖的场景）、<code>SRANDMEMBER</code>（随机获取集合中的元素，适合允许重复中奖的场景）。</p>
<h3 id="Sorted-Set（有序集合）"><a href="#Sorted-Set（有序集合）" class="headerlink" title="Sorted Set（有序集合）"></a>Sorted Set（有序集合）</h3><p>Sorted Set 类似于 Set，但和 Set 相比，Sorted Set 增加了一个权重参数 <code>score</code>，使得集合中的元素能够按 <code>score</code> 进行有序排列，还可以通过 <code>score</code> 的范围来获取元素的列表。有点像是 Java 中 <code>HashMap</code> 和 <code>TreeSet</code> 的结合体。</p>
<hr>
<p>应用场景</p>
<ul>
<li><strong>需要随机获取数据源中的元素根据某个权重进行排序的场景</strong></li>
</ul>
<p>各种排行榜比如直播间送礼物的排行榜、朋友圈的微信步数排行榜、王者荣耀中的段位排行榜、话题热度排行榜等等。</p>
<ul>
<li><strong>需要存储的数据有优先级或者重要程度的场景</strong> 比如优先级任务队列。</li>
</ul>
<p>优先级任务队列。</p>
<h2 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h2><p>Redis的基本数据类型都是以键值对的形式保存在一张哈希表中，哈希表其实就是一个数组，数组中的元素叫做哈希桶。</p>
<p>哈希桶存放的是指向键值对数据的指针（dictEntry*），这样通过指针就能找到键值对数据，然后因为键值对的值可以保存字符串对象和集合数据类型的对象，所以键值对的数据结构中并不是直接保存值本身，而是保存了 void * key 和 void * value 指针，分别指向了实际的键对象和值对象，这样一来，即使值是集合数据，也可以通过 void * value 指针找到。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/9fa26a74965efbf0f56b707a03bb9b7f-20230309232518487.png" alt="img"></p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/3c386666e4e7638a07b230ba14b400fe.png" alt="img"></p>
<ul>
<li>redisDb 结构，表示 Redis 数据库的结构，结构体里存放了指向了 dict 结构的指针；</li>
<li>dict 结构，结构体里存放了 2 个哈希表，正常情况下都是用「哈希表1」，「哈希表2」只有在 rehash 的时候才用，具体什么是 rehash，我在本文的哈希表数据结构会讲；</li>
<li>ditctht 结构，表示哈希表的结构，结构里存放了哈希表数组，数组中的每个元素都是指向一个哈希表节点结构（dictEntry）的指针；</li>
<li>dictEntry 结构，表示哈希表节点的结构，结构里存放了 **void * key 和 void * value 指针， *key 指向的是 String 对象，而 *value 则可以指向 String 对象，也可以指向集合类型的对象，比如 List 对象、Hash 对象、Set 对象和 Zset 对象**。</li>
</ul>
<p>void * key 和 void * value 指针指向redis对象</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/58d3987af2af868dca965193fb27c464.png" alt="img"></p>
<h3 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h3><p>简单动态字符串</p>
<p>不使用c语言原本char*数组的原因：</p>
<ul>
<li>获取字符串长度需遍历整个字符串，时间复杂度为O（n）</li>
<li>\0表示字符串结尾，如果字符串本身就有\0就会提前结束</li>
<li>字符串操作不安全，容易导致缓冲区溢出</li>
<li>只能保存文本数据，不能保存图像、音频、视频二进制文件</li>
</ul>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/516738c4058cdf9109e40a7812ef4239.png" alt="img"></p>
<ul>
<li><strong>len，记录了字符串长度</strong>。这样获取字符串长度的时候，只需要返回这个成员变量值就行，时间复杂度只需要 O（1）。</li>
<li><strong>alloc，分配给字符数组的空间长度</strong>。这样在修改字符串的时候，可以通过 <code>alloc - len</code> 计算出剩余的空间大小，可以用来判断空间是否满足修改需求，如果不满足的话，就会自动将 SDS 的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用 SDS 既不需要手动修改 SDS 的空间大小，也不会出现前面所说的缓冲区溢出的问题。</li>
<li><strong>flags，用来表示不同类型的 SDS</strong>。一共设计了 5 种类型，分别是 sdshdr5、sdshdr8、sdshdr16、sdshdr32 和 sdshdr64，后面在说明区别之处。</li>
<li><strong>buf[]，字符数组，用来保存实际数据</strong>。不仅可以保存字符串，也可以保存二进制数据。</li>
</ul>
<h4 id="SDS自动扩容"><a href="#SDS自动扩容" class="headerlink" title="SDS自动扩容"></a><strong>SDS自动扩容</strong></h4><ul>
<li>如果所需的 sds 长度<strong>小于 1 MB</strong>，那么最后的扩容是按照<strong>翻倍扩容</strong>来执行的，即 2 倍的newlen</li>
<li>如果所需的 sds 长度<strong>超过 1 MB</strong>，那么最后的扩容长度应该是 newlen <strong>+ 1MB</strong>。</li>
</ul>
<p>SDS API除了分配必要的空间，还会额外分配【未使用的空间】，<strong>有效减少内存分配次数</strong></p>
<h4 id="节省内存空间"><a href="#节省内存空间" class="headerlink" title="节省内存空间"></a><strong>节省内存空间</strong></h4><p><strong>之所以 SDS 设计不同类型的结构体，是为了能灵活保存不同大小的字符串，从而有效节省内存空间。</strong></p>
<p>除了设计不同类型的结构体，Redis 在编程上还<strong>使用了专门的编译优化来节省内存空间</strong>，即在 struct 声明了 <code>__attribute__ ((packed))</code> ，它的作用是：<strong>告诉编译器取消结构体在编译过程中的优化对齐，按照实际占用字节数进行对齐</strong>。</p>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p><img src="https://cdn.xiaolincoding.com//mysql/other/cadf797496816eb343a19c2451437f1e.png" alt="img"></p>
<p>list结构 + 双向链表</p>
<p>list结构存放双向链表的一些信息</p>
<p><strong>Redis 的链表实现优点如下：</strong></p>
<ul>
<li>listNode 链表节点的结构里带有 prev 和 next 指针，<strong>获取某个节点的前置节点或后置节点的时间复杂度只需O(1)，而且这两个指针都可以指向 NULL，所以链表是无环链表</strong>；</li>
<li>list 结构因为提供了表头指针 head 和表尾节点 tail，所以**获取链表的表头节点和表尾节点的时间复杂度只需O(1)**；</li>
<li>list 结构因为提供了链表节点数量 len，所以**获取链表中的节点数量的时间复杂度只需O(1)**；</li>
<li>listNode 链表节使用 void* 指针保存节点值，并且可以通过 list 结构的 dup、free、match 函数指针为节点设置该节点类型特定的函数，因此<strong>链表节点可以保存各种不同类型的值</strong>；</li>
</ul>
<p><strong>链表的缺陷也是有的：</strong></p>
<ul>
<li>链表每个节点之间的内存都是不连续的，意味着<strong>无法很好利用 CPU 缓存</strong>。能很好利用 CPU 缓存的数据结构就是数组，因为数组的内存是连续的，这样就可以充分利用 CPU 缓存来加速访问。</li>
<li>还有一点，保存一个链表节点的值都需要一个链表节点结构头的分配，<strong>内存开销较大</strong>。</li>
</ul>
<h3 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h3><p>压缩列表的最大特点，就是它被设计成一种内存紧凑型的数据结构，占用一块连续的内存空间，不仅可以利用 CPU 缓存，而且会针对不同长度的数据，进行相应编码，这种方法可以有效地节省内存开销。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/a3b1f6235cf0587115b21312fe60289c.png" alt="img"></p>
<p>但是，压缩列表的缺陷也是有的：</p>
<ul>
<li>不能保存过多的元素，否则查询效率就会降低；</li>
<li>新增或修改某个元素时，压缩列表占用的内存空间需要重新分配，甚至可能引发连锁更新的问题。</li>
</ul>
<p><strong>连锁更新</strong></p>
<p>压缩列表除了查找复杂度高的问题，还有一个问题。</p>
<p><strong>压缩列表新增某个元素或修改某个元素时，如果空间不不够，压缩列表占用的内存空间就需要重新分配。而当新插入的元素较大时，可能会导致后续元素的 prevlen 占用空间都发生变化，从而引起「连锁更新」问题，导致每个元素的空间都要重新分配，造成访问压缩列表性能的下降</strong>。</p>
<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>哈希表优点在于，它<strong>能以 O(1) 的复杂度快速查询数据</strong>。怎么做到的呢？将 key 通过 Hash 函数的计算，就能定位数据在表中的位置，因为哈希表实际上是数组，所以可以通过索引值快速查询到数据。</p>
<p>但是存在的风险也是有，在哈希表大小固定的情况下，随着数据不断增多，那么<strong>哈希冲突</strong>的可能性也会越高。</p>
<p>解决哈希冲突的方式，有很多种。</p>
<p><strong>Redis 采用了「链式哈希」来解决哈希冲突</strong>，在不扩容哈希表的前提下，将具有相同哈希值的数据串起来，形成链接起，以便这些数据在表中仍然可以被查询到。</p>
<p>不过，链式哈希局限性也很明显，随着链表长度的增加，在查询这一位置上的数据的耗时就会增加，毕竟链表的查询的时间复杂度是 O(n)。</p>
<p>要想解决这一问题，就需要进行 rehash，也就是对哈希表的大小进行扩展。</p>
<h4 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h4><p>Redis 定义一个 dict 结构体，这个结构体里定义了<strong>两个哈希表（ht[2]）</strong>。</p>
<p>在rehash的时候会使用第二个hash表</p>
<p>在正常服务请求阶段，插入的数据，都会写入到「哈希表 1」，此时的「哈希表 2 」 并没有被分配空间。</p>
<p>随着数据逐步增多，触发了 rehash 操作，这个过程分为三步：</p>
<ul>
<li>给「哈希表 2」 分配空间，一般会比「哈希表 1」 大 2 倍；</li>
<li>将「哈希表 1 」的数据迁移到「哈希表 2」 中；</li>
<li>迁移完成后，「哈希表 1 」的空间会被释放，并把「哈希表 2」 设置为「哈希表 1」，然后在「哈希表 2」 新创建一个空白的哈希表，为下次 rehash 做准备。</li>
</ul>
<h4 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h4><p>为了避免 rehash 在数据迁移过程中，因拷贝数据的耗时，影响 Redis 性能的情况，所以 Redis 采用了<strong>渐进式 rehash</strong>，也就是将数据的迁移的工作不再是一次性迁移完成，而是分多次迁移。</p>
<p>渐进式 rehash 步骤如下：</p>
<ul>
<li>给「哈希表 2」 分配空间；</li>
<li><strong>在 rehash 进行期间，每次哈希表元素进行新增、删除、查找或者更新操作时，Redis 除了会执行对应的操作之外，还会顺序将「哈希表 1 」中索引位置上的所有 key-value 迁移到「哈希表 2」 上</strong>；</li>
<li>随着处理客户端发起的哈希表操作请求数量越多，最终在某个时间点会把「哈希表 1 」的所有 key-value 迁移到「哈希表 2」，从而完成 rehash 操作。</li>
</ul>
<h4 id="rehash触发条件"><a href="#rehash触发条件" class="headerlink" title="rehash触发条件"></a>rehash触发条件</h4><p>负载因子 &#x3D; 哈希表已保存节点数量 &#x2F; 哈希表大小</p>
<ul>
<li><strong>当负载因子大于等于 1 ，并且 Redis 没有在执行 bgsave 命令或者 bgrewiteaof 命令，也就是没有执行 RDB 快照或没有进行 AOF 重写的时候，就会进行 rehash 操作。</strong></li>
<li><strong>当负载因子大于等于 5 时，此时说明哈希冲突非常严重了，不管有没有有在执行 RDB 快照或 AOF 重写，都会强制进行 rehash 操作。</strong></li>
</ul>
<h3 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h3><p>整数集合是 Set 对象的底层实现之一。当一个 Set 对象只包含整数值元素，并且元素数量不大时，就会使用整数集这个数据结构作为底层实现。</p>
<h4 id="整数集合的升级操作"><a href="#整数集合的升级操作" class="headerlink" title="整数集合的升级操作"></a>整数集合的升级操作</h4><p>整数集合会有一个升级规则，就是当我们将一个新元素加入到整数集合里面，如果新元素的类型（int32_t）比整数集合现有所有元素的类型（int16_t）都要长时，整数集合需要先进行升级，也就是按新元素的类型（int32_t）扩展 contents 数组的空间大小，然后才能将新元素加入到整数集合里，当然升级的过程中，也要维持整数集合的有序性。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/5dbdfa7cfbdd1d12a4d9458c6c90d472.png" alt="img"></p>
<p>现在，往这个整数集合中加入一个新元素 65535，这个新元素需要用 int32_t 类型来保存，所以整数集合要进行升级操作，首先需要为 contents 数组扩容，<strong>在原本空间的大小之上再扩容多 80 位（4x32-3x16&#x3D;80），这样就能保存下 4 个类型为 int32_t 的元素</strong>。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/e2e3e19fc934e70563fbdfde2af39a2b.png" alt="img"></p>
<p>扩容完 contents 数组空间大小后，需要将之前的三个元素转换为 int32_t 类型，并将转换后的元素放置到正确的位上面，并且需要维持底层数组的有序性不变，整个转换过程如下：</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/e84b052381e240eeb8cc97d6b729968b.png" alt="img"></p>
<p>因此，整数集合升级的好处是<strong>节省内存资源</strong>。</p>
<p><strong>不支持降级</strong></p>
<h3 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h3><p>链表在查找元素的时候，因为需要逐一查找，所以查询效率非常低，时间复杂度是O(N)，于是就出现了跳表。<strong>跳表是在链表基础上改进过来的，实现了一种「多层」的有序链表</strong>，这样的好处是能快读定位数据。</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/3%E5%B1%82%E8%B7%B3%E8%A1%A8-%E8%B7%A8%E5%BA%A6.png" alt="img"></p>
<p><strong>跨度实际上是为了计算这个节点在跳表中的排位</strong>。</p>
<h4 id="跳表节点查询过程"><a href="#跳表节点查询过程" class="headerlink" title="跳表节点查询过程"></a>跳表节点查询过程</h4><p>查找一个跳表节点的过程时，跳表会从头节点的最高层开始，逐一遍历每一层。在遍历某一层的跳表节点时，会用跳表节点中的 SDS 类型的元素和元素的权重来进行判断，共有两个判断条件：</p>
<ul>
<li>如果当前节点的权重「小于」要查找的权重时，跳表就会访问该层上的下一个节点。</li>
<li>如果当前节点的权重「等于」要查找的权重时，并且当前节点的 SDS 类型数据「小于」要查找的数据时，跳表就会访问该层上的下一个节点。</li>
</ul>
<p>如果上面两个条件都不满足，或者下一个节点为空时，跳表就会使用目前遍历到的节点的 level 数组里的下一层指针，然后沿着下一层指针继续查找，这就相当于跳到了下一层接着查找。</p>
<h4 id="跳表节点层数设置"><a href="#跳表节点层数设置" class="headerlink" title="跳表节点层数设置"></a>跳表节点层数设置</h4><p>跳表的相邻两层的节点数量的比例会影响跳表的查询性能。</p>
<p>**跳表的相邻两层的节点数量最理想的比例是 2:1，查找复杂度可以降低到 O(logN)**。</p>
<p>如果采用新增节点或者删除节点时，来调整跳表节点以维持比例的方法的话，会带来额外的开销。</p>
<p><font color='blue'><strong>那怎样才能维持相邻两层的节点数量的比例为 2 : 1 呢？</strong> </font></p>
<p>Redis 则采用一种巧妙的方法是，<strong>跳表在创建节点的时候，随机生成每个节点的层数</strong>，并没有严格维持相邻两层的节点数量比例为 2 : 1 的情况。</p>
<p>具体的做法是，<strong>跳表在创建节点时候，会生成范围为[0-1]的一个随机数，如果这个随机数小于 0.25（相当于概率 25%），那么层数就增加 1 层，然后继续生成下一个随机数，直到随机数的结果大于 0.25 结束，最终确定该节点的层数</strong>。</p>
<p>这样的做法，相当于每增加一层的概率不超过 25%，层数越高，概率越低，层高最大限制是 64。</p>
<p><font color='blue'><strong>为什么用跳表而不用平衡树？</strong> </font></p>
<ul>
<li><strong>从内存占用上来比较，跳表比平衡树更灵活一些</strong>。平衡树每个节点包含 2 个指针（分别指向左右子树），而跳表每个节点包含的指针数目平均为 1&#x2F;(1-p)，具体取决于参数 p 的大小。如果像 Redis里的实现一样，取 p&#x3D;1&#x2F;4，那么平均每个节点包含 1.33 个指针，比平衡树更有优势。</li>
<li><strong>在做范围查找的时候，跳表比平衡树操作要简单</strong>。在平衡树上，我们找到指定范围的小值之后，还需要以<strong>中序遍历</strong>的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在跳表上进行范围查找就非常简单，只需要在找到小值之后，对第 1 层链表进行若干步的遍历就可以实现。</li>
<li><strong>从算法实现难度上来比较，跳表比平衡树要简单得多</strong>。平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而跳表的插入和删除只需要修改相邻节点的指针，操作简单又快速。</li>
</ul>
<h3 id="quicklist"><a href="#quicklist" class="headerlink" title="quicklist"></a>quicklist</h3><p>其实 quicklist 就是「双向链表 + 压缩列表」组合，因为一个 quicklist 就是一个链表，而链表中的每个元素又是一个压缩列表。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/f46cbe347f65ded522f1cc3fd8dba549.png" alt="img"></p>
<p>quicklist 会控制 quicklistNode 结构里的压缩列表的大小或者元素个数，来规避潜在的连锁更新的风险，但是这并没有完全解决连锁更新的问题。</p>
<h3 id="listpack"><a href="#listpack" class="headerlink" title="listpack"></a>listpack</h3><p>于是，Redis 在 5.0 新设计一个数据结构叫 listpack，目的是替代压缩列表，它最大特点是 listpack 中每个节点不再包含前一个节点的长度了，压缩列表每个节点正因为需要保存前一个节点的长度字段，就会有连锁更新的隐患。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/c5fb0a602d4caaca37ff0357f05b0abf.png" alt="img"></p>
<ul>
<li>encoding，定义该元素的编码类型，会对不同长度的整数和字符串进行编码；</li>
<li>data，实际存放的数据；</li>
<li>len，encoding+data的总长度；</li>
</ul>
<p><font color='blue'><strong>压缩列表的entry为什么要保存prevlen呢？listpack改成len之后不会影响功能吗？</strong> </font></p>
<p>压缩列表的 entry 保存 prevlen 是为了实现节点从后往前遍历，知道前一个节点的长度，就可以计算前一个节点的偏移量。</p>
<p>listpack 一样可以支持从后往前遍历的。详细的算法可以看：<a target="_blank" rel="noopener" href="https://github.com/antirez/listpack/blob/master/listpack.c">https://github.com/antirez/listpack/blob/master/listpack.c</a> 里的lpDecodeBacklen函数，lpDecodeBacklen 函数就可以从当前列表项起始位置的指针开始，向左逐个字节解析，得到前一项的 entry-len 值。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="http://example.com">John Doe</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2023/03/27/Redis/">http://example.com/2023/03/27/Redis/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/03/27/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/" title="测试文章"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">测试文章</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">John Doe</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis"><span class="toc-number">1.</span> <span class="toc-text">Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#redis%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.0.1.</span> <span class="toc-text">redis线程模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">1.0.2.</span> <span class="toc-text">redis持久化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4"><span class="toc-number">1.0.3.</span> <span class="toc-text">redis过期删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0"><span class="toc-number">1.0.4.</span> <span class="toc-text">redis内存淘汰</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.0.5.</span> <span class="toc-text">redis缓存设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5"><span class="toc-number">1.0.6.</span> <span class="toc-text">redis缓存更新策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis%E5%AE%9E%E6%88%98"><span class="toc-number">1.0.7.</span> <span class="toc-text">redis实战</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#redis%E5%AE%9E%E7%8E%B0%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97"><span class="toc-number">1.0.7.1.</span> <span class="toc-text">redis实现延迟队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redis%E5%A4%A7key"><span class="toc-number">1.0.7.2.</span> <span class="toc-text">redis大key</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redis%E4%B8%8D%E6%94%AF%E6%8C%81%E5%9B%9E%E6%BB%9A"><span class="toc-number">1.0.7.3.</span> <span class="toc-text">redis不支持回滚</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">1.0.7.4.</span> <span class="toc-text">redis实现分布式锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E4%B8%AA%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">5个基本数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#String%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%89"><span class="toc-number">1.1.1.</span> <span class="toc-text">String（字符串）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List%EF%BC%88%E5%88%97%E8%A1%A8%EF%BC%89"><span class="toc-number">1.1.2.</span> <span class="toc-text">List（列表）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hash%EF%BC%88%E5%93%88%E5%B8%8C%EF%BC%89"><span class="toc-number">1.1.3.</span> <span class="toc-text">Hash（哈希）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89"><span class="toc-number">1.1.4.</span> <span class="toc-text">Set（集合）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sorted-Set%EF%BC%88%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%EF%BC%89"><span class="toc-number">1.1.5.</span> <span class="toc-text">Sorted Set（有序集合）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">Redis数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SDS"><span class="toc-number">1.2.1.</span> <span class="toc-text">SDS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SDS%E8%87%AA%E5%8A%A8%E6%89%A9%E5%AE%B9"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">SDS自动扩容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8A%82%E7%9C%81%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">节省内存空间</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">1.2.2.</span> <span class="toc-text">链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8"><span class="toc-number">1.2.3.</span> <span class="toc-text">压缩列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">1.2.4.</span> <span class="toc-text">哈希表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#rehash"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">rehash</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%90%E8%BF%9B%E5%BC%8Frehash"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">渐进式rehash</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rehash%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">rehash触发条件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88"><span class="toc-number">1.2.5.</span> <span class="toc-text">整数集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88%E7%9A%84%E5%8D%87%E7%BA%A7%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">整数集合的升级操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%B3%E8%A1%A8"><span class="toc-number">1.2.6.</span> <span class="toc-text">跳表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%B3%E8%A1%A8%E8%8A%82%E7%82%B9%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B"><span class="toc-number">1.2.6.1.</span> <span class="toc-text">跳表节点查询过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%B3%E8%A1%A8%E8%8A%82%E7%82%B9%E5%B1%82%E6%95%B0%E8%AE%BE%E7%BD%AE"><span class="toc-number">1.2.6.2.</span> <span class="toc-text">跳表节点层数设置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#quicklist"><span class="toc-number">1.2.7.</span> <span class="toc-text">quicklist</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#listpack"><span class="toc-number">1.2.8.</span> <span class="toc-text">listpack</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/27/Redis/" title="Hello World">Hello World</a><time datetime="2023-03-27T05:08:51.016Z" title="Created 2023-03-27 13:08:51">2023-03-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/27/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/" title="测试文章">测试文章</a><time datetime="2023-03-27T05:04:21.000Z" title="Created 2023-03-27 13:04:21">2023-03-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/27/hello-world/" title="Hello World">Hello World</a><time datetime="2023-03-27T03:26:19.353Z" title="Created 2023-03-27 11:26:19">2023-03-27</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By John Doe</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>